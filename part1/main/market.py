from concurrent import futures
import logging
import math
import time

#import grpc
import grpc

#import all classes generated by grpc
import all_pb2
import all_pb2_grpc

"""Class to structure products"""
class ProductDetails:
    def __init__(self, name,item_id, item_price, quantity, category, description, rating, seller_address):
        self.name = name
        self.item_id = item_id
        self.item_price = item_price
        self.quantity = quantity
        self.category = category
        self.description = description
        self.rating = rating
        self.seller_address = seller_address

"""Class to send notifications to the clients"""
class NotifClient():

    def __init__(self):
        self.seller_ip = -1
        self.seller_port = -1
        self.buyer_ip = -1
        self.buyer_port = -1
        self.uuid_map = dict()

    def store_mapping(self, uuid, product):
        if uuid not in self.uuid_map:
            self.uuid_map[uuid]=[]
        self.uuid_map[uuid].append(product)

    """
    set mode=0 -> seller_notif_server
    set mode=1 -> buyer_notif_server
    """
    def run(self, notif, mode):

        if (mode == 0): #seller_notif_server
            comm_channel = str(self.seller_ip) + ":" + str(self.seller_port)
        else:
            comm_channel = str(self.buyer_ip) + ":" + str(self.buyer_port)
        
        #setting channel of communication after retrieving info from the stored mapping
        with grpc.insecure_channel(comm_channel) as channel:
            stub = all_pb2_grpc.AllServicesStub(channel)
            messsage_info=notif
            notification_mess=all_pb2.Notification(message=messsage_info)
            notify_request=stub.NotifyClient(notification_mess)
            print(notify_request.message)    

class AllServicesServicer(all_pb2_grpc.AllServicesServicer):
    """ Add methods to implement functionality of the services required by the seller"""

    def __init__(self):
        self.registered_sellers = []
        self.products=[]
        self.registered_buyers = []
        self.notifier = NotifClient()

    def RegisterSeller(self, request, context):
        #extract uuid and add key to dictionary
        curr_seller_uuid = request.message
        server_response=all_pb2.RegisterSellerResponse()

        #extract seller_notif_server info 
        if (self.notifier.seller_ip == -1):
            self.notifier.seller_ip = request.notif_server_ip

        if (self.notifier.seller_port == -1):
            self.notifier.seller_port = request.notif_server_port

        #validate user
        if (curr_seller_uuid in self.registered_sellers):
            server_response.message= "FAILURE: USER ALREADY EXISTS"
        else:
            self.registered_sellers.append(curr_seller_uuid)
            server_response.message= "SUCCESS: USER ADDED w/ UUID " + curr_seller_uuid
        return server_response
    
    def SellItem(self, request, context):

        #retrieve item info
        curr_item_id = request.item.item_id
        curr_item_name = request.item.name
        curr_item_price = request.item.item_price
        curr_item_quantity = request.item.quantity
        curr_item_category = request.item.category
        curr_item_description = request.item.description
        curr_item_selleraddress = request.item.seller_address
        server_response = all_pb2.SellItemResponse()

        if (curr_item_selleraddress not in self.registered_sellers):
            server_response.message = "FAILURE, USER NOT REGISTERED"
            return server_response

        new_prod = ProductDetails(curr_item_name,
                                  curr_item_id, 
                                  curr_item_price,
                                  curr_item_quantity,
                                  curr_item_category,
                                  curr_item_description,
                                  -1,
                                  curr_item_selleraddress)
        

        #add products to product list if it doesn't already exist
        for product in self.products:
            if (product.item_id == curr_item_id): #product already exists, return failure
                server_response.message = "FAILURE, ITEM ALREADY EXISTS"
                return server_response
            
        #product doesn't exist
        self.products.append(new_prod)

        server_response.message = "SUCCESS, ITEM ADDED SUCCESSFULLY"
        return server_response
    
    def UpdateItem(self, request, context):

        #retrieve info from the update item request
        some_id = request.seller_id #this is the seller uuid that the product originally has
        req_item_id = request.item_id
        new_item_price = request.new_item_price
        new_item_quantity = request.new_quantity

        #new seller uuid not needed but too lazy to change and recompile the proto files

        server_response = all_pb2.UpdateItemResponse()

        #search for item in the products list, validate seller credentials and update
        for item in self.products:
            if (item.item_id == req_item_id and item.seller_address == some_id):
                item.item_price = new_item_price
                item.quantity = new_item_quantity
                server_response.message = "SUCCESS"


                #issue notification to people that have wishlisted the product
                for buyer in self.notifier.uuid_map:
                    if (item.item_id in self.notifier.uuid_map[buyer]):
                        notif_message = f"Notification for buyer {buyer}: {item.name} w/ id {item.item_id} has now been updated"
                        self.notifier.run(notif_message,1)

                return server_response
        
        #failed either because no item match found or invalid credentials
        server_response.message = "FAILURE"
        return server_response
    
    def DeleteItem(self, request, context):

        #retrieve info from the delete item request
        req_item_id = request.item_id
        seller_uuid = request.seller_address

        server_response = all_pb2.DeleteItemResponse()

        #search for item in the products list, validate credentials and delete
        for item in self.products:
            if (item.item_id == req_item_id and item.seller_address == seller_uuid):
                self.products.remove(item)
                server_response.message = f"DELETED ITEM W/ ITEM ID:{req_item_id} SUCCESSFULLY"

                return server_response
            
        #failure to delete the requested item either because item not found in the products list or credentials not verified
        server_response.message = "FAILURE"
        return server_response
    
    def DisplaySellerItems(self, request, context):
        #retrieve uuid of the seller
        seller_uuid = request.seller_id

        response=all_pb2.DisplaySellerItemsResponse()

        for i in self.products:
            if (i.seller_address == seller_uuid):
                item=all_pb2.Item()
                item.name=i.name
                item.category=i.category
                item.item_price=i.item_price
                item.quantity=i.quantity
                item.description=i.description
                item.seller_address=i.seller_address
                item.item_id=i.item_id
                item.rating = i.rating
                response.items.append(item)
        
        return response
    
    def RegisterBuyer(self, request, context):
        #extract uuid and add key to dictionary
        curr_buyer_uuid = request.message
        server_response=all_pb2.RegisterBuyerResponse()

        #extract seller_notif_server info 
        if (self.notifier.buyer_ip == -1):
            self.notifier.buyer_ip = request.notif_server_ip

        if (self.notifier.seller_port == -1):
            self.notifier.buyer_port = request.notif_server_port

        #validate user
        if (curr_buyer_uuid in self.registered_buyers):
            server_response.message= "FAILURE: USER ALREADY EXISTS"
        else:
            self.registered_buyers.append(curr_buyer_uuid)
            server_response.message= "SUCCESS: USER ADDED w/ UUID " + curr_buyer_uuid
        return server_response

   
    def SearchItem(self, request,context):
        item_name=request.item_name
        item_category=request.category_name

        response = all_pb2.SearchItemResponse()

        for i in self.products:
            if ((i.category==item_category) or item_category=="ANY") and (i.name==item_name or item_name==""):
                item=all_pb2.Item()
                item.name=i.name
                item.category=i.category
                item.item_price=i.item_price
                item.quantity=i.quantity
                item.description=i.description
                item.seller_address=i.seller_address
                item.item_id=i.item_id
                item.rating = i.rating
                response.items.append(item)
    
        return response
        
    def BuyItem(self, request, context):
        item_id=request.item_id
        item_quantity=request.item_quantity
        flag =False

        seller_uuid = -1
        bought_item_name = ""
        product_quantity_bought = -1

        for i in self.products:
            if item_id==i.item_id and item_quantity<=i.quantity and i.quantity>0:
                i.quantity-=item_quantity
                flag=True

                #storing info for notif message
                seller_uuid = i.seller_address
                product_quantity_bought = item_quantity
                bought_item_name = i.name
                break

        notif_message = f"SELLER {seller_uuid} has sold {product_quantity_bought} units of {bought_item_name}"

        response=all_pb2.BuyItemResponse()
        if(not flag):
            response.status="Failure"
        else:
            self.notifier.run(notif_message, 0)
            response.status="Success"
        return response

    def AddToWishList(self, request, context):

        #retrieve buyer info and id of the item to wishlist
        wishlisted_item_id = request.item_id
        user_uuid_wishlist = request.buyer_uuid

        #store in the wishlist dict (key = buyer_uuid, value = wishlist)
        self.notifier.store_mapping(user_uuid_wishlist, wishlisted_item_id)
        response = all_pb2.AddToWishListResponse()
        response.status = f"ITEM ADDED TO WISHLIST of {user_uuid_wishlist} SUCCESSFULLY"
        return response

    def RateItem(self, request, context):
        item_name=request.item_id
        item_rating=request.rating
        server_response = all_pb2.RateItemResponse()
        for i in self.products:
            if (i.item_id==item_name):
                i.rating=item_rating
                server_response.status=f"UPDATED RATING OF ITEM W/ ITEM ID:{item_name} SUCCESSFULLY"
                return server_response
        server_response.status = "FAILURE"
        return server_response    

    
def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    all_pb2_grpc.add_AllServicesServicer_to_server(
        AllServicesServicer(), server
    )
    server.add_insecure_port("[::]:50051")
    server.start()
    server.wait_for_termination()

if __name__ == "__main__":
    logging.basicConfig()
    serve()